import 'dart:async';

import 'package:core/coop/change.dart';
import 'package:core/core.dart';
import 'package:core/core_property_changes.dart';
import 'package:meta/meta.dart';
import 'package:local_data/local_data.dart';
import 'package:rive_core/rive_file.dart';

class TestChanges {
  final ChangeSet changeSet;
  final Completer<bool> _completer = Completer<bool>();
  Future<bool> accept() => _completer.future;
  bool get isCompleted => _completer.isCompleted;
  TestChanges(this.changeSet);
}

class TestRiveFile extends RiveFile {
  final Map<String, dynamic> overridePreferences;
  final bool useSharedPreferences;

  TestRiveFile(
    String fileId, {
    @required LocalDataPlatform localDataPlatform,
    this.overridePreferences,
    this.useSharedPreferences = true,
  }) : super(
          fileId,
          localDataPlatform: localDataPlatform,
        );

  @override
  Future<int> getIntSetting(String key) async {
    if (overridePreferences != null) {
      dynamic val = overridePreferences[key];
      if (val is int) {
        return val;
      }
    }
    if (!useSharedPreferences) {
      return null;
    }
    return super.getIntSetting(key);
  }

  @override
  Future<String> getStringSetting(String key) async {
    if (overridePreferences != null) {
      dynamic val = overridePreferences[key];
      if (val is String) {
        return val;
      }
    }
    if (!useSharedPreferences) {
      return null;
    }
    return super.getStringSetting(key);
  }

  @override
  Future<void> setIntSetting(String key, int value) async {
    if (!useSharedPreferences) {
      return;
    }
    return super.setIntSetting(key, value);
  }

  @override
  Future<void> setStringSetting(String key, String value) async {
    if (!useSharedPreferences) {
      return;
    }
    return super.setStringSetting(key, value);
  }

  final _changeSetCompleters = Expando<TestChanges>();

  Completer<ChangeSet> _nextPropertyChanges;
  Completer<ChangeSet> waitForNextChanges() =>
      _nextPropertyChanges = Completer<ChangeSet>();

  @override
  void receiveCoopChanges(ChangeSet changes) {
    super.receiveCoopChanges(changes);
    var completer = _nextPropertyChanges;
    _nextPropertyChanges = null;
    completer?.complete(changes);
  }

  @override
  ChangeSet coopMakeChangeSet(CorePropertyChanges changes, {bool useFrom}) {
    return _lastMadeChanges =
        super.coopMakeChangeSet(changes, useFrom: useFrom);
  }

  // Hackity hack hack, but at least it's only for testing.
  ChangeSet _lastMadeChanges;

  /// Effectively the same thing as when the editor would call
  /// captureJournalEntry but we get a changeset back that we can await to test
  /// whether rejected or accepted.
  TestChanges captureTestChanges() {
    // Just in case, reset _lastMadeChanges as we really only want it to track
    // the changes generated by the next call to captureJournalEntry, we just
    // want to override the whole pipeline...so this is an easy hack for tests.
    _lastMadeChanges = null;
    if (captureJournalEntry()) {
      // Map from the changes to a completer. N.B. we have to do this (instead
      // of subclassing ChangeSet) as ChangeSet gets sent to an isolate and must
      // be pure data (no completers/stored closures/etc).
      var testChanges = TestChanges(_lastMadeChanges);
      _changeSetCompleters[_lastMadeChanges] = testChanges;
      return testChanges;
    }
    return null;
  }

  @override
  void changesAccepted(ChangeSet changes) {
    super.changesAccepted(changes);
    _changeSetCompleters[changes]?._completer?.complete(true);
  }

  @override
  Future<void> changesRejected(ChangeSet changes) async {
    _changeSetCompleters[changes]?._completer?.complete(false);
    await super.changesRejected(changes);
  }

  Future<void> settle() async {
    while (freshChanges.isNotEmpty) {
      await Future<void>.delayed(const Duration(milliseconds: 100));
    }
  }

  /// Returns true if the system has an inflight change for the object with
  /// [objectId] and property with [propertyKey].
  bool hasInflightChanges(Id objectId, int propertyKey) {
    var objectFlight = inflight[objectId];
    if (objectFlight == null) {
      return false;
    }
    var value = objectFlight[propertyKey];
    return value != null && value > 0;
  }
}
