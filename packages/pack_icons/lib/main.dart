import 'dart:async';
import 'dart:io';

import 'package:dart_style/dart_style.dart';
import 'package:image/image.dart';
import 'package:utilities/bitmap_packer/bitmap_rect.dart';
import 'package:utilities/bitmap_packer/multi_atlas_packer.dart';
import 'package:crypto/crypto.dart';

class BitmapRectAtlas {
  final int scale;
  final int index;
  final BitmapRect rect;

  BitmapRectAtlas(this.scale, this.index, this.rect);
}

Map<String, List<BitmapRectAtlas>> _icons = {};
Map<Image, String> _imageNames = {};

Future<void> main(List<String> args) async {
  if (args.length != 3) {
    print('Source and destination folders need to be specified.');
    exit(1);
  }
  String directory = args[0];
  String dest = args[1];
  String dartFilename = args[2];

  var cachebust = await packAtlas(1, directory, dest);
  await packAtlas(2, '$directory/2.0x', dest, postfix: cachebust);
  await packAtlas(3, '$directory/3.0x', dest, postfix: cachebust);

  final code = StringBuffer();

  code.write('''
    import 'package:meta/meta.dart';

    @immutable
    /// Autogenerated class for icons automatically exported and packed from the
    /// Rive Figma design file. See dev/extract_icons.sh and dev/pack_icons.sh.
    class PackedIcon {
      final int x, y, width, height;
      final int scale;
      final int index;

      static const String cachebust = '$cachebust';

      const PackedIcon._(this.x, this.y, this.width, this.height,
          this.scale, this.index);
  ''');
  _icons.forEach((name, rects) {
    code.writeln('static const Iterable<PackedIcon> $name = [');
    for (final icon in rects) {
      code.writeln(
          'PackedIcon._(${icon.rect.x}, ${icon.rect.y}, ${icon.rect.width}, '
          ' ${icon.rect.height}, ${icon.scale}, ${icon.index}),');
    }
    code.writeln('];');
  });
  code.write('''
    }
    ''');

  final _formatter = DartFormatter();
  var formattedCode = _formatter.format(code.toString());

  File(dartFilename).writeAsStringSync(formattedCode);
}

Future<String> packAtlas(int scale, String directory, String dest,
    {String postfix}) async {
  String cachebust = postfix;
  var completer = Completer<String>();
  var packer =
      MultiAtlasPacker(maxWidth: 1024, maxHeight: 1024, allowRotations: false);
  Directory(directory).list(recursive: false).listen((entity) {
    if (entity is File && entity.path.toLowerCase().endsWith('.png')) {
      var image = decodeImage(File(entity.path).readAsBytesSync());
      packer.addBitmap(image.width, image.height, 0, image);

      var name = entity.path.toLowerCase();
      name = name.substring(name.lastIndexOf('/') + 1);
      name = name.substring(0, name.lastIndexOf('.'));
      var expression = RegExp('(-|\\s|_)([^-\\s_]+)');
      name = name.replaceAllMapped(
          expression,
          (match) =>
              match.group(2)[0].toUpperCase() + match.group(2).substring(1));
      name = name.replaceAll(' ', '');
      _imageNames[image] = name;
    }
  }, onDone: () {
    var result = packer.build();
    int atlasIndex = 0;
    for (final atlas in result) {
      var results = atlas.results;
      atlas.initImage();
      for (final rect in results) {
        var image = (rect.userData as BitmapRect).userData as Image;
        atlas.copyPixels(rect, image.data);
        var name = _imageNames[image];
        _icons[name] ??= [];
        _icons[name].add(BitmapRectAtlas(scale, atlasIndex, rect));
      }

      // Once all images are copied, we can save the atlas image.
      var image =
          Image.fromBytes(atlas.imageWidth, atlas.imageHeight, atlas.image);

      cachebust ??= sha1.convert(atlas.image).toString();
      var filename = '$dest/${scale}x\_$atlasIndex\_$cachebust.png';
      File(filename).createSync(recursive: true);
      File(filename).writeAsBytesSync(encodePng(image));
      atlasIndex++;
    }
    completer.complete(cachebust);
  });
  return completer.future;
}
